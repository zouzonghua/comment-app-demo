{"version":3,"sources":["components/CommentInput.jsx","reducers/comments.js","containers/CommentInput.jsx","components/Comment.jsx","components/CommentList.jsx","containers/CommentList.jsx","containers/CommentApp.jsx","App.js","serviceWorker.js","index.js"],"names":["CommentInput","props","state","username","content","this","textarea","focus","e","onUserNameInputBlur","target","value","setState","onSubmit","createdTime","Date","className","type","onBlur","handleUsernameBlur","onChange","handleUsernameChange","ref","handleContentChange","onClick","handleSubmit","Component","defaultProps","CommentInputContainer","_loadUsername","window","localStorage","getItem","setItem","comment","alert","comments","newComments","JSON","stringify","_saveUsername","handleSubmitComment","connect","dispatch","addComment","Comment","timeString","_updateTimeString","bind","handleDeleteComment","_timer","setInterval","clearInterval","duration","now","Math","round","max","replace","onDeleteComment","index","dangerouslySetInnerHTML","__html","_getProcessedContent","CommentList","map","i","key","CommentListContainer","_loadComments","parse","initComments","slice","commentIndex","deleteComment","CommentApp","store","createStore","action","App","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.41cfb379.chunk.js","sourcesContent":["import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nexport default class CommentInput extends Component {\n  static propTypes = {\n    username: PropTypes.any,\n    onSubmit: PropTypes.func,\n    onUserNameInputBlur: PropTypes.func\n  }\n\n  static defaultProps = {\n    username: ''\n  }\n\n  constructor (props) {\n    super(props)\n    this.state = {\n      username: props.username,\n      content: ''\n    }\n  }\n\n  componentDidMount () {\n    this.textarea.focus()\n  }\n\n  handleUsernameBlur (e) {\n    if (this.props.onUserNameInputBlur) {\n      this.props.onUserNameInputBlur(e.target.value)\n    }\n  }\n\n  handleUsernameChange (e) {\n    this.setState({\n      username: e.target.value\n    })\n  }\n\n  handleContentChange (e) {\n    this.setState({\n      content: e.target.value\n    })\n  }\n\n  handleSubmit () {\n    if (this.props.onSubmit) {\n      const { username, content } = this.state\n      this.props.onSubmit({\n        username,\n        content,\n        createdTime: +new Date()\n      })\n    }\n    this.setState({ content: '' })\n  }\n\n  render () {\n    return (\n      <div className='comment-input'>\n\n        <div className='comment-field'>\n          <span className='comment-field-name'>用户名：</span>\n          <div className='comment-field-input'>\n            <input\n              type='text'\n              value={this.state.username}\n              onBlur={(e) => this.handleUsernameBlur(e)}\n              onChange={(e) => this.handleUsernameChange(e)}\n            />\n          </div>\n        </div>\n\n        <div className='comment-field'>\n          <span className='comment-field-name'>评论内容：</span>\n          <div className='comment-field-input'>\n            <textarea\n              // eslint-disable-next-line no-return-assign\n              ref={(textarea) => this.textarea = textarea}\n              value={this.state.content}\n              onChange={(e) => this.handleContentChange(e)}\n            />\n          </div>\n        </div>\n\n        <div className='comment-field-button'>\n          <button onClick={() => this.handleSubmit()}>\n            发布\n          </button>\n        </div>\n\n      </div>\n    )\n  }\n}\n\n// CommentInput.propTypes = {\n//   onSubmit: PropTypes.func\n// }\n","// action types\nconst INIT_COMMENTS = 'INIT_COMMENTS'\nconst ADD_COMMENT = 'ADD_COMMENT'\nconst DELETE_COMMENT = 'DELETE_COMMENT'\n\nexport default (state, action) => {\n  if (!state) {\n    state = { comments: [] }\n  }\n\n  switch (action.type) {\n    case INIT_COMMENTS:\n      // 初始化评论\n      return { comments: action.comments }\n    case ADD_COMMENT:\n      // 新增评论\n      return {\n        comments: [...state.comments, action.comment]\n      }\n    case DELETE_COMMENT:\n      // 删除评论\n      return {\n        comments: [\n          ...state.comments.slice(0, action.commentIndex),\n          ...state.comments.slice(action.commentIndex + 1)\n        ]\n      }\n    default:\n      return state\n  }\n}\n\n// action creators\nexport const initComments = (comments) => {\n  return { type: INIT_COMMENTS, comments }\n}\n\nexport const addComment = (comment) => {\n  return { type: ADD_COMMENT, comment }\n}\n\nexport const deleteComment = (commentIndex) => {\n  return { type: DELETE_COMMENT, commentIndex }\n}\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\nimport CommentInput from '../components/CommentInput'\nimport { addComment } from '../reducers/comments'\n\n// CommentInputContainer\n// 负责用户名到加载、保存，评论到发布\nclass CommentInputContainer extends Component {\n  static propTypes = {\n    comments: PropTypes.array,\n    onSubmit: PropTypes.func\n  }\n\n  constructor () {\n    super()\n    this.state = { username: '' }\n  }\n\n  componentWillMount () {\n    this._loadUsername()\n  }\n\n  /**\n   * @description 从 LocalStorage 加载 username\n   * @author zouzonghua\n   * @Date 2019-09-05 15:49:22\n   */\n  _loadUsername () {\n    // 然后可以在 render 方法中传给 CommentInput\n    const username = window.localStorage.getItem('username')\n    if (username) {\n      this.setState({ username })\n    }\n  }\n\n  /**\n   * @description 保存 username 到 LocalStorage\n   * @author zouzonghua\n   * @param {String} username\n   * @Date 2019-09-05 15:50:07\n   */\n  _saveUsername (username) {\n    // 看看 render 方法的 onUserNameInputBlur\n    // 这个方法会在用户名输入框 blur 的时候的被调用，保存用户名\n    window.localStorage.setItem('username', username)\n  }\n\n  /**\n   * @description 提交评论\n   * @author zouzonghua\n   * @param {Object} comment\n   * @Date 2019-09-05 15:51:47\n   */\n  handleSubmitComment (comment) {\n    // 评论数据到验证\n    if (!comment) return\n    if (!comment.username) return window.alert('请输入用户名')\n    if (!comment.content) return window.alert('请输入评论内容')\n\n    // 新增评论保存到 LocalStorage 中\n    const { comments } = this.props\n    const newComments = [...comments, comment]\n    window.localStorage.setItem('comments', JSON.stringify(newComments))\n\n    if (this.props.onSubmit) {\n      this.props.onSubmit(comment)\n    }\n  }\n\n  render () {\n    return (\n      <CommentInput\n        username={this.state.username}\n        onUserNameInputBlur={(e) => this._saveUsername(e)}\n        onSubmit={(comment) => this.handleSubmitComment(comment)}\n      />\n    )\n  }\n}\n\nconst mapStateToProps = state => {\n  return {\n    comments: state.comments\n  }\n}\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    onSubmit: comment => {\n      dispatch(addComment(comment))\n    }\n  }\n}\n\nexport default connect(\n  mapStateToProps,\n  mapDispatchToProps\n)(CommentInputContainer)\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nexport default class Comment extends Component {\n  static propTypes = {\n    comment: PropTypes.object.isRequired,\n    onDeleteComment: PropTypes.func,\n    index: PropTypes.number\n  }\n\n  constructor () {\n    super()\n    this.state = {\n      timeString: ''\n    }\n    this._updateTimeString = this._updateTimeString.bind(this)\n    this.handleDeleteComment = this.handleDeleteComment.bind(this)\n  }\n\n  componentWillMount () {\n    this._updateTimeString()\n    this._timer = setInterval(() => {\n      this._updateTimeString()\n    }, 5000)\n  }\n\n  componentWillUnmount () {\n    clearInterval(this._timer)\n  }\n\n  /**\n   * 更新评论创建时间\n   */\n  _updateTimeString () {\n    const { comment } = this.props\n    const duration = (+Date.now() - comment.createdTime) / 1000\n    this.setState({\n      timeString: duration > 60\n        ? `${Math.round(duration / 60)} 分钟前`\n        : `${Math.round(Math.max(duration, 1))} 秒前`\n    })\n  }\n\n  /**\n   * 处理评论内容 用户在的输入内容中任何以 `` 包含的内容都会用 <code> 包含起来显示到页面上\n   * @param {String} content 评论内容\n   */\n  _getProcessedContent (content) {\n    return content\n      .replace(/&/g, '&amp;')\n      .replace(/</g, '&lt;')\n      .replace(/>/g, '&gt;')\n      .replace(/\"/g, '&quot;')\n      .replace(/'/g, '&#039;')\n      .replace(/`([\\S\\s]+?)`/g, '<code>$1</code>')\n  }\n\n  handleDeleteComment () {\n    if (this.props.onDeleteComment) {\n      this.props.onDeleteComment(this.props.index)\n    }\n  }\n\n  render () {\n    const { username, content } = this.props.comment\n    const { timeString } = this.state\n\n    return (\n      <div className='comment'>\n        <div className='comment-user'>\n          <span>{username}</span> ：\n        </div>\n        <p dangerouslySetInnerHTML={{ __html: this._getProcessedContent(content) }} />\n        <span className='comment-createdtime'>\n          {timeString}\n        </span>\n        <span\n          onClick={this.handleDeleteComment}\n          className='comment-delete'\n        >\n          删除\n        </span>\n      </div>\n    )\n  }\n}\n// Comment.propTypes = {\n//   comment: PropTypes.object.isRequired\n// }\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\n\nimport Comment from './Comment'\n\nexport default class CommentList extends Component {\n  static propTypes = {\n    comments: PropTypes.array,\n    onDeleteComment: PropTypes.func\n  }\n\n  constructor () {\n    super()\n    this.handleDeleteComment = this.handleDeleteComment.bind(this)\n  }\n\n  handleDeleteComment (index) {\n    if (this.props.onDeleteComment) {\n      this.props.onDeleteComment(index)\n    }\n  }\n\n  render () {\n    const { comments } = this.props\n    return (\n      <div>\n        {comments.map((comment, i) =>\n          <Comment\n            comment={comment}\n            key={i}\n            index={i}\n            onDeleteComment={this.handleDeleteComment}\n          />\n        )}\n      </div>\n    )\n  }\n}\n","import React, { Component } from 'react'\nimport PropTypes from 'prop-types'\nimport { connect } from 'react-redux'\nimport CommentList from '../components/CommentList'\nimport { initComments, deleteComment } from '../reducers/comments'\n\n// CommentListContainer\n// 一个 smart 组件，负责评论列表数据的加载、初始化、删除评论\n// 沟通 CommentList 和 this.state.\nclass CommentListContainer extends Component {\n  static propTypes = {\n    comments: PropTypes.array,\n    initComments: PropTypes.func,\n    onDeleteComment: PropTypes.func\n  }\n\n  componentWillMount () {\n    this._loadComments()\n  }\n\n  /**\n   * @description 从 LocalStorage 中加载评论\n   * @author zouzonghua\n   * @Date 2019-09-05 14:49:46\n   */\n  _loadComments () {\n    let comments = window.localStorage.getItem('comments')\n    comments = comments ? JSON.parse(comments) : []\n    this.props.initComments(comments)\n  }\n\n  handleDeleteComment (index) {\n    const { comments } = this.props\n    // props 是不能变的，所以这里新建一个删除了特定下标的评论列表\n    const newComments = [\n      ...comments.slice(0, index),\n      ...comments.slice(index + 1)\n    ]\n\n    // 保存最新评论列表到 localStorage\n    window.localStorage.setItem('comments', JSON.stringify(newComments))\n\n    if (this.props.onDeleteComment) {\n      // this.props.onDeleteComment 是 connect 传进来的\n      // 会 dispatch 一个 action 去删除评论\n      this.props.onDeleteComment(index)\n    }\n  }\n\n  render () {\n    return (\n      <CommentList\n        comments={this.props.comments}\n        onDeleteComment={(index) => this.handleDeleteComment(index)}\n      />\n    )\n  }\n}\n\nconst mapStateToProps = (state) => {\n  return {\n    comments: state.comments\n  }\n}\n\nconst mapDispatchToProps = (dispatch) => {\n  return {\n    // 提供给 CommentListContainer\n    // 当从 LocalStorage 加载评论列表以后就会通过这个方法\n    // 把评论列表初始化到 state 当中\n    initComments: (comments) => {\n      dispatch(initComments(comments))\n    },\n    // 删除评论\n    onDeleteComment: (commentIndex) => {\n      dispatch(deleteComment(commentIndex))\n    }\n  }\n}\n\n// 将 CommentListContainer connect 到 store\n// 会把 comments、initComments、onDeleteComment 传给 CommentListContainer\nexport default connect(mapStateToProps, mapDispatchToProps)(CommentListContainer)\n","import React, { Component } from 'react'\nimport CommentInput from './CommentInput'\nimport CommentList from './CommentList'\n\nexport default class CommentApp extends Component {\n  render () {\n    return (\n      <div className='wrapper'>\n        <CommentInput />\n        <CommentList />\n      </div>\n    )\n  }\n}\n","import React from 'react'\n// import './App.css'\n// import CommentApp from './components/CommentApp'\n// import Index from './components/Index'\n// import { Provider } from './components/ReactRedux'\nimport { Provider } from 'react-redux'\nimport { createStore } from 'redux'\nimport CommentApp from './containers/CommentApp'\nimport comments from './reducers/comments'\n\n// function createStore (reducer) {\n//   let state = null\n//   const listeners = []\n//   // 传入监听函数\n//   const subscribe = (listener) => listeners.push(listener)\n//   const getState = () => state\n//   const dispatch = (action) => {\n//     state = reducer(state, action) // 覆盖原对象\n//     // 每次数据改变遍历数组执行监听函数渲染数据\n//     listeners.forEach((listener) => {\n//       listener()\n//     })\n//   }\n//   dispatch({}) // 初始化 state\n//   return { getState, dispatch, subscribe }\n// }\n\n// const themeReducer = (state, action) => {\n//   if (!state) {\n//     return {\n//       themeColor: 'red'\n//     }\n//   }\n\n//   switch (action.type) {\n//     case 'CHANGE_COLOR':\n//       return { ...state, themeColor: action.themeColor }\n//     default:\n//       return state\n//   }\n// }\n\n// const store = createStore(themeReducer)\nconst store = createStore(comments)\n\nfunction App () {\n  return (\n    <div className='App'>\n      {/* <Provider store={store}>\n        <Index />\n      </Provider> */}\n      {/* <CommentApp /> */}\n      <Provider store={store}>\n        <CommentApp />\n      </Provider>\n    </div>\n  )\n}\n\nexport default App\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister()\n\n/**\n * 动手实现 Redux（一）：优雅地修改共享状态\n */\n// const appState = {\n//   title: {\n//     text: 'React.js 小书',\n//     color: 'red'\n//   },\n//   content: {\n//     text: 'React.js 小书内容',\n//     color: 'blue'\n//   }\n// }\n\n// function dispatch (action) {\n//   switch (action.type) {\n//     case 'UPDATE_TITLE_TEXT':\n//       appState.title.text = action.text\n//       break\n//     case 'UPDATE_TITLE_COLOR':\n//       appState.title.color = action.color\n//       break\n//     default:\n//       break\n//   }\n// }\n\n// function renderApp (appState) {\n//   renderTitle(appState.title)\n//   renderContent(appState.content)\n// }\n\n// function renderTitle (title) {\n//   const titleDOM = document.getElementById('title')\n//   titleDOM.innerHTML = title.text\n//   titleDOM.style.color = title.color\n// }\n\n// function renderContent (content) {\n//   const contentDOM = document.getElementById('content')\n//   contentDOM.innerHTML = content.text\n//   contentDOM.style.color = content.color\n// }\n\n// renderApp(appState)\n// dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' })\n// dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' })\n// renderApp(appState)\n\n/**\n * 动手实现 Redux（二）：抽离 store 和监控数据变化\n */\n// const appState = {\n//   title: {\n//     text: 'React.js 小书',\n//     color: 'red'\n//   },\n//   content: {\n//     text: 'React.js 小书内容',\n//     color: 'blue'\n//   }\n// }\n\n// function stateChanger (state, action) {\n//   switch (action.type) {\n//     case 'UPDATE_TITLE_TEXT':\n//       state.title.text = action.text\n//       break\n//     case 'UPDATE_TITLE_COLOR':\n//       state.title.color = action.color\n//       break\n//     default:\n//       break\n//   }\n// }\n\n// function createStore (state, stateChanger) {\n//   const listeners = []\n//   // 传入监听函数\n//   const subscribe = (listener) => listeners.push(listener)\n//   const getState = () => state\n//   const dispatch = (action) => {\n//     stateChanger(state, action)\n//     // 每次数据改变遍历数组执行监听函数渲染数据\n//     listeners.forEach((listener) => {\n//       listener()\n//     })\n//   }\n//   return { getState, dispatch, subscribe }\n// }\n\n// function renderApp (appState) {\n//   renderTitle(appState.title)\n//   renderContent(appState.content)\n// }\n\n// function renderTitle (title) {\n//   const titleDOM = document.getElementById('title')\n//   titleDOM.innerHTML = title.text\n//   titleDOM.style.color = title.color\n// }\n\n// function renderContent (content) {\n//   const contentDOM = document.getElementById('content')\n//   contentDOM.innerHTML = content.text\n//   contentDOM.style.color = content.color\n// }\n\n// const store = createStore(appState, stateChanger)\n// store.subscribe(() => renderApp(store.getState())) // 监听数据变化\n\n// renderApp(store.getState()) // 首次渲染页面\n// store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' })\n// store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' })\n// store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'red' })\n\n/**\n * 动手实现 Redux（三）：纯函数（Pure Function）简介\n */\n\n/**\n * 不是纯函数\n * 不是一个纯函数，因为它返回的结果依赖于外部变量 a，我们在不知道 a 的值的情况下，并不能保证 foo(2) 的返回值是 3。\n */\n// const a = 1\n// const foo = (b) => a + b\n// console.log(foo(2))\n\n/**\n * 纯函数\n * 纯函数的第一个条件：一个函数的返回结果只依赖于它的参数。\n */\n// const a = 1\n// const foo = (x, b) => x + b\n// console.log(foo(a, 2))\n\n/**\n * 不是纯函数\n * 函数执行过程产生了副作用\n * 在 foo 内部加了一句 obj.x = 2，计算前 counter.x 是 1，但是计算以后 counter.x 是 2。foo 函数的执行对外部的 counter 产生了影响，它产生了副作用，因为它修改了外部传进来的对象，现在它是不纯的。\n */\n// const foo = (obj, b) => {\n//   obj.x = 2\n//   return obj.x + b\n// }\n\n// const counter = { x: 1 }\n\n// console.log(foo(counter, 2))\n// console.log(counter.x)\n\n/**\n * 纯函数\n * 函数执行过程没有副作用\n * 虽然 foo 函数内部修改了 obj，但是 obj 是内部变量，外部程序根本观察不到，修改 obj 并不会产生外部可观察的变化，这个函数是没有副作用的，因此它是一个纯函数。\n */\n\n// const foo = (b) => {\n//   const obj = { x: 1 }\n//   obj.x = 2\n//   return obj.x + b\n// }\n\n// console.log(foo(2))\n\n// 一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。\n\n// 为什么要煞费苦心地构建纯函数？因为纯函数非常“靠谱”，执行一个纯函数你不用担心它会干什么坏事，它不会产生不可预料的行为，也不会对外部产生影响。不管何时何地，你给它什么它就会乖乖地吐出什么。如果你的应用程序大多数函数都是由纯函数组成，那么你的程序测试、调试起来会非常方便。\n\n/**\n * 动手实现 Redux（四）：共享结构的对象提高性能\n */\n\n// const appState = {\n//   title: {\n//     text: 'React.js 小书',\n//     color: 'red'\n//   },\n//   content: {\n//     text: 'React.js 小书内容',\n//     color: 'blue'\n//   }\n// }\n\n// function stateChanger (state, action) {\n//   switch (action.type) {\n//     case 'UPDATE_TITLE_TEXT':\n//       return { // 构建新的对象并且返回\n//         ...state,\n//         title: {\n//           ...state.title,\n//           text: action.text\n//         }\n//       }\n//       // state.title.text = action.text\n//     case 'UPDATE_TITLE_COLOR':\n//       return { // 构建新的对象并且返回\n//         ...state,\n//         title: {\n//           ...state.title,\n//           color: action.color\n//         }\n//       }\n//     default:\n//       return state // 没有修改，返回原来的对象\n//   }\n// }\n\n// function createStore (state, stateChanger) {\n//   const listeners = []\n//   // 传入监听函数\n//   const subscribe = (listener) => listeners.push(listener)\n//   const getState = () => state\n//   const dispatch = (action) => {\n//     state = stateChanger(state, action) // 覆盖原对象\n//     // 每次数据改变遍历数组执行监听函数渲染数据\n//     listeners.forEach((listener) => {\n//       listener()\n//     })\n//   }\n//   return { getState, dispatch, subscribe }\n// }\n\n// function renderApp (newAppState, oldAppState = {}) { // 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = {}\n//   if (newAppState === oldAppState) return // 数据没有变化就不渲染\n//   console.log('render app...')\n//   renderTitle(newAppState.title, oldAppState.title)\n//   renderContent(newAppState.content, oldAppState.content)\n// }\n\n// function renderTitle (newTitle, oldTitle) {\n//   if (newTitle === oldTitle) return\n//   console.log('render title...')\n//   const titleDOM = document.getElementById('title')\n//   titleDOM.innerHTML = newTitle.text\n//   titleDOM.style.color = newTitle.color\n// }\n\n// function renderContent (newContent, oldContent) {\n//   if (newContent === oldContent) return\n//   console.log('render content...')\n//   const contentDOM = document.getElementById('content')\n//   contentDOM.innerHTML = newContent.text\n//   contentDOM.style.color = newContent.color\n// }\n\n// const store = createStore(appState, stateChanger)\n// let oldStore = store.getState() // 缓存旧的 state\n// store.subscribe(() => {\n//   const newStore = store.getState() // 数据可能变化，获取新的 state\n//   renderApp(newStore, oldStore)// 把新旧的 state 传进去渲染\n//   oldStore = newStore\n// }) // 监听数据变化\n\n// renderApp(store.getState()) // 首次渲染页面\n// store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' })\n// store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' })\n\n/**\n * 动手实现 Redux（五）：不要问为什么的 reducer\n */\n\n// function stateChanger (state, action) {\n//   if (!state) {\n//     return {\n//       title: {\n//         text: 'React.js 小书',\n//         color: 'red'\n//       },\n//       content: {\n//         text: 'React.js 小书内容',\n//         color: 'blue'\n//       }\n//     }\n//   }\n//   switch (action.type) {\n//     case 'UPDATE_TITLE_TEXT':\n//       return { // 构建新的对象并且返回\n//         ...state,\n//         title: {\n//           ...state.title,\n//           text: action.text\n//         }\n//       }\n//     case 'UPDATE_TITLE_COLOR':\n//       return { // 构建新的对象并且返回\n//         ...state,\n//         title: {\n//           ...state.title,\n//           color: action.color\n//         }\n//       }\n//     default:\n//       return state // 没有修改，返回原来的对象\n//   }\n// }\n\n// function createStore (reducer) {\n//   let state = null\n//   const listeners = []\n//   // 传入监听函数\n//   const subscribe = (listener) => listeners.push(listener)\n//   const getState = () => state\n//   const dispatch = (action) => {\n//     state = reducer(state, action) // 覆盖原对象\n//     // 每次数据改变遍历数组执行监听函数渲染数据\n//     listeners.forEach((listener) => {\n//       listener()\n//     })\n//   }\n//   dispatch({}) // 初始化 state\n//   return { getState, dispatch, subscribe }\n// }\n\n// function renderApp (newAppState, oldAppState = {}) { // 防止 oldAppState 没有传入，所以加了默认参数 oldAppState = {}\n//   if (newAppState === oldAppState) return // 数据没有变化就不渲染\n//   console.log('render app...')\n//   renderTitle(newAppState.title, oldAppState.title)\n//   renderContent(newAppState.content, oldAppState.content)\n// }\n\n// function renderTitle (newTitle, oldTitle) {\n//   if (newTitle === oldTitle) return\n//   console.log('render title...')\n//   const titleDOM = document.getElementById('title')\n//   titleDOM.innerHTML = newTitle.text\n//   titleDOM.style.color = newTitle.color\n// }\n\n// function renderContent (newContent, oldContent) {\n//   if (newContent === oldContent) return\n//   console.log('render content...')\n//   const contentDOM = document.getElementById('content')\n//   contentDOM.innerHTML = newContent.text\n//   contentDOM.style.color = newContent.color\n// }\n\n// const store = createStore(stateChanger)\n// let oldStore = store.getState() // 缓存旧的 state\n// store.subscribe(() => {\n//   const newStore = store.getState() // 数据可能变化，获取新的 state\n//   renderApp(newStore, oldStore)// 把新旧的 state 传进去渲染\n//   oldStore = newStore\n// }) // 监听数据变化\n\n// renderApp(store.getState()) // 首次渲染页面\n// store.dispatch({ type: 'UPDATE_TITLE_TEXT', text: '《React.js 小书》' })\n// store.dispatch({ type: 'UPDATE_TITLE_COLOR', color: 'blue' })\n"],"sourceRoot":""}